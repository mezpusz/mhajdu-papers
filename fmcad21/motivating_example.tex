% !TeX root = ./paper.tex

%\begin{figure}
%\footnotesize
%\begin{minipage}[t]{0.4\textwidth}
%$$\begin{aligned}&\forall y.\add(0,y):=y\\
%&\forall x,y.\add(\suc(x),y):=\suc(\add(x,y))\\
%\end{aligned}$$
%\hrule
%$$\begin{aligned}&\even(0):=\top\\
%&\even.2:\even(\suc(0)):=\bot\\
%&\forall z.\even(\suc(\suc(z))):=\even(z)\\
%\end{aligned}$$
%\hrule
%$$\begin{aligned}&\half(0):=0\\
%&\half(\suc(0)):=0\\
%&\forall x.\half(\suc(\suc(x)):=\suc(\half(x))\\
%\end{aligned}$$\end{minipage}
%\begin{minipage}[t]{0.5\textwidth}
%$$\begin{aligned}&\size(\bnil):=0\\
%&\forall x,y,z.\size(\bnode(x,y,z)):=\suc(\add(\size(x),\size(z)))\\
%\end{aligned}$$
%\hrule
%$$\begin{aligned}
%&\brotate(\bnil):=\nil\\
%&\forall x,y,z,u,v.\brotate(\bnode(\bnode(x,y,z),u,v)):=\\&\quad\brotate(\bnode(x,y,\bnode(z,u,v)))
%\end{aligned}$$
%\end{minipage}
%%$$\begin{aligned}&\forall y.\add(0,y)&&:=y&&\forall x.\nil\append x&&:=x\\
%%&\forall x,y.\add(\suc(x),y)&&:=\suc(\add(x,y))&&\forall x,y,z.\cons(x,y)\append z&&:=\cons(x,y\append z)\\
%%\cline{1-8}
%%&\even(0)&&:=\top&&\fltn(\bnil)&&:=\nil\\
%%&\even(\suc(0))&&:=\bot&&\forall u,v,w.\fltn(\bnode(u,v,w))&&:=\\
%%&\forall z.\even(\suc(\suc(z)))&&:=\even(z)&&\phantom{aa}\fltn(u)\append\cons(v,\fltn(w))\\
%%\cline{1-8}
%%&\forall x.\fleq(0,x)&&:=\top&&\forall x.\fltn_2(\bnil,x)&&:=x\\
%%&\forall x.\fleq(\suc(x),0)&&:=\bot&&\forall u,v,w,y.\fltn_2(\bnode(u,v,w),y)&&:=\\
%%&\forall x,y.\fleq(\suc(x), \suc(y))&&:=\fleq(x, y)&&\phantom{aa}\fltn_2(u,\cons(v,\fltn_2(w,y)))\\
%%\end{aligned}$$
%\caption{Recursive function definitions used}
%\label{fig:functions}
%\end{figure}
%\normalsize

\begin{example}\label{ex:1}
Given function definitions $\append : (\lst,\lst)\rightarrow\lst$ and $\rev:(\lst)\rightarrow\lst$ characterized by:
\begin{align}
&\append(\nil)\rightsquigarrow y\label{app1}\tag{app.1}\\ &\append(\cons(u,v))\rightsquigarrow\cons(u,\append(v,y))\label{app2}\tag{app.2}\end{align}
\dotfill
\begin{align}
&\rev(\nil)\rightsquigarrow \nil\label{rev1}\tag{rev.1}\\ &\rev(\cons(u,v))\rightsquigarrow\append(\rev(v),\cons(u,\nil))\label{rev2}\tag{rev.2}\end{align}

Prove the following:
$$\forall x. \rev(\rev(x))=x$$
A manual proof starts with choosing a suitable induction formula and proving its antecedent. The simplest formula contains two conjuncts in the antecedent:
\begin{equation}\label{eq:ex1.1}\rev(\rev(\nil)) = \nil\tag{1.1}\end{equation}
Proving \eqref{eq:ex1.1} is trivial by definition \eqref{rev1}. The second conjunct is the step case with term $\cons(z,y)$ using induction hypothesis $y$:
\begin{align}\begin{split}\forall z,y.\big(\rev(\rev(y))=y\rightarrow\\\rev(\rev(\cons(z,y)))=\cons(z,y)\big)\end{split}\label{eq:ex1.2}\tag{1.2}\end{align}
After expanding $\rev(\cons(z,y))$ in the conclusion with \eqref{rev2}, we can use the induction hypothesis in a right-to-left orientation on the right-hand side:
$$\forall z,y.\rev(\append(\rev(y),\cons(z,\nil)))=\cons(z,\rev(\rev(y)))$$
One more induction step is required, now with a \textit{generalized} induction formula, with a conclusion where $\rev(y)$ matches a fresh variable $u$:
$$\forall z,u.\rev(\append(u,\cons(z,\nil)))=\cons(z,\rev(u))$$
Using a similar case distinction and following the same recipe, that is, applying function definitions of $\rev$ and $\append$ and rewriting with the induction hypothesis leads to success.
\end{example}

For saturation-based theorem provers, it is very hard to prove the above theorem using standard techniques -- rewriting with the induction hypothesis in the right-to-left order gives the ordering obligation $x \succ \rev(\rev(x))$, which is impossible in any simplification ordering $\succ$.

Apart from that, especially recursive cases of some function definitions are hard to orient in their natural way because their bodies can contain arbitrarily large terms with functors including the top-most of the header. Here, orienting \eqref{rev2} in the natural way is often not possible.

Let us look at another example:
\begin{example}\label{ex:2}
	Given function definitions $\add : (\nat,\nat)\rightarrow\nat$ and $\mul : (\nat,\nat)\rightarrow\nat$ and predicate definition $\even : (\nat)$ given by the rules:
	\begin{align}
	&\add(\zero,y)\rightsquigarrow y\label{add1}\tag{add.1}\\ &\add(\suc(z),y)\rightsquigarrow\suc(\add(z,y))\label{add2}\tag{add.2}\end{align}
	\dotfill
	\begin{align}
	&\mul(\zero,y)\rightsquigarrow \zero\label{mul1}\tag{mul.1}\\
    &\mul(\suc(z),y)\rightsquigarrow \add(\mul(z,y),y)\label{mul2}\tag{mul.2}\end{align}
	\dotfill
	\begin{align}
	&\even(\zero)\quad\neg\even(\suc(\zero))\label{even12}\tag{even.1\&2}\\
	&\even(\suc(\suc(z)))\leftrightarrow \even(z)\label{even3}\tag{even.3}\end{align}
	Prove the conjecture:
	$$\forall x,y. \even(y)\rightarrow \even(\mul(x,y))$$
	Here, inducting on $x$ with the simplest case distinction for $\nat$ gives us the following cases:
	\begin{equation}\forall y. \even(y)\rightarrow \even(\mul(\zero,y))\tag{2.1}\end{equation}
	The conclusion reduces to true using \eqref{mul1} and \eqref{even12}. The second case is:
	\begin{align}\begin{split}\forall z,y. \big((\even(y)\rightarrow \even(\mul(z,y)))\rightarrow\\
	(\even(y)\rightarrow \even(\mul(\suc(z),y)))\big)\end{split}\tag{2.2}\end{align}
	After applying \eqref{mul2} and "factoring out" the duplicate antecedent $\even(y)$, we get:
	$$\forall z,y. \even(y)\rightarrow\begin{pmatrix}\even(\mul(z,y))\rightarrow\\
	\even(\add(\mul(z,y),y))\end{pmatrix}$$
	As opposed to Example \ref{ex:1}, here we cannot use the induction hypothesis because it does not match the conclusion. One might recognize however that the hypothesis and conclusion share a complex term $\mul(z,y)$. In fact, we can induct on the whole formula, generalizing over this term.

	We use a different case distinction, $\zero\mid\suc(\zero)\mid u\rightarrow\suc(\suc(u))$. The reason we cannot use the simpler case distinction from earlier is because we need a step case that matches \eqref{even3}, so we can simplify it:
    $$\forall y,u. \even(y)\rightarrow\begin{pmatrix}(\even(u)\rightarrow\even(\add(u,y)))\rightarrow\\
    (\even(\suc(\suc(u)))\rightarrow\even(\add(\suc(\suc(u)),y)))\end{pmatrix}$$
    Using \eqref{add2} and \eqref{even3} leads to the step conclusion matching exactly its hypothesis. It is also interesting to note that the second base case:
	$$\forall y. \even(y)\rightarrow\begin{pmatrix}\even(\suc(\zero))\rightarrow\\
	\even(\add(\suc(\zero),y))\end{pmatrix}$$
	is only valid since the antecedent of the inner implication is false:
	$$\forall y. \even(y)\rightarrow(\bot\rightarrow\even(\suc(y)))$$
\end{example}

There are two pivotal parts in the above proof that make it hard for an automated prover. The first one is to carry the assumptions in both induction steps. This may seem obvious for human and e.g. SMT solvers or proof assistants. Saturation-based theorem provers usually perform induction in a splitting manner on the clausal form of a goal, that is, for a clause $L_1\lor...\lor L_n$, each $L_i$ is inducted upon until we get the empty clause.

The second pivotal point is the non-trivial induction formula in the second step. This can be guessed based on the definition of $\even$.

\subsection{Contributions}

